# Lambda Calculus

λ演算（英语：lambda calculus，λ-calculus）是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在20世纪30年代首次发表。lambda演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程；尽管如此，lambda演算强调的是变换规则的运用，而非实现它们的具体机器。

lambda演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种更接近软件而非硬件的方式。对函数式编程语言造成很大影响，比如Lisp、ML语言和Haskell语言。在1936年邱奇利用λ演算给出了对于判定性问题（Entscheidungsproblem）的否定：关于两个lambda表达式是否等价的命题，无法由一个“通用的算法”判断，这是不可判定性能够证明的头一个问题，甚至还在停机问题之先。lambda演算包括了建构lambda项，和对lambda项运行归约的操作。

**Lambda演算中的所有函数都是匿名的，它们没有名称，它们只接受一个输入变量，柯里化用于实现有多个输入变量的函数。**

### 简单符号标识

丘奇等数学家给出了解决方法：λ演算。基本定义形式如下，

 > λ<变量>.<表达式>

用这种方法定义的函数叫λ表达式。λx.x2-2\*x+1 就是一个λ表达式，其中显式地指出了x是变量。
当将这个λ表达式定义应用于具体的变量值时，需要用一对括号把表达式括起来，比如，

 > (λx.x2-2\*x+1)1

应用过程是把变量值赋值给表达式中的x，并去掉 λ<变量>，过程如下，

 > (λx.x2-2\*x+1)1=1-2\*1+1=0

调用过程如下，

 > ( ( λx.λy.2\*x+y) 1) 2 = ( λy.2+y) 2 = 4

其中，x=1,y=2，也就是说计算顺序是固定的，从里层到外层一层层归约，如果改变变量的次序也会影响函数应用中的返回值，比如，
这便是语义。

这里也可以看到就是，函数的返回值也可以是一个函数，这样不同函数的层次问题也解决了，也就是传统数学中高阶函数、泛函的表示。在函数式编程语言中函数是一等公民与此也是一致的。
λ演算之所以被程序语言学家如此推崇，正是因为λ演算系统的构建过程就是一个程序语言从无到有的构建过程，整个系统中任何一个复杂的λ表达式都是由：λ抽象、应用和括号，粘合在一起的：）

### LC 优点

   - 非常简单
   - 图灵完备
   - 容易读写
   - 语义足够强大
   - 有很好的实体模型
   - 容易创建变种

纯粹的 Lambda 演算中一切都是函数， 变量都没有。 

### LC 定义元素：

   - 语法
   - 一组规则

### LC 三类表达式
   - 函数定义： Lambda演算中的函数是一个表达式，写成：lambda x . body，表示“一个参数参数为x的函数，它的返回值为body的计算结果。” 这时我们说：Lambda表达式绑定了参数x。
   - 标识符引用 ： 标识符引用就是一个名字，这个名字用于匹配函数表达式中的某个参数名。
   - 函数应用： 函数应用写成把函数值放到它的参数前面的形式，如(lambda x . plus x x) y

### 柯里化
在Lambda演算中有一个技巧：如果你看一下上面的定义，你会发现一个函数（Lambda表达式）只接受一个参数。这似乎是一个很大的局限 —— 你怎么能在只有一个参数的情况下实现加法？
这一点问题都没有，因为函数就是值。你可以写只有一个参数的函数，而这个函数返回一个带一个参数的函数，这样就可以实现写两个参数的函数了——本质上两者是一样的。这就是所谓的柯里化（Currying），以伟大的逻辑学家Haskell Curry命名。
例如我们想写一个函数来实现x + y。我们比较习惯写成类似：lambda x y . plus x y之类的东西。而采用单个参数函数的写法是：我们写一个只有一个参数的函数，让它返回另一个只有一个参数的函数。于是x + y就变成一个单参数x的函数，它返回另一个函数，这个函数将x加到它自己的参数上：

 > lambda x. ( lambda y. plus x y )

### 自由标识符 vs. 绑定标识符
有一个重要的语法问题我还没有提到：闭包（closure）或者叫完全绑定（complete binding）。在对一个Lambda演算表达式进行求值的时候，不能引用任何未绑定的标识符。如果一个标识符是一个闭合Lambda表达式的参数，我们则称这个标识符是（被）绑定的；如果一个标识符在任何封闭上下文中都没有绑定，那么它被称为**自由变量**。
lambda x . plus x y：在这个表达式中，y和plus是自由的，因为他们不是任何闭合的Lambda表达式的参数；而x是绑定的，因为它是函数定义的闭合表达式plus x y的参数。
lambda x y . y x ：在这个表达式中x和y都是被绑定的，因为它们都是函数定义中的参数。
lambda y . (lambda x . plus x y)：在内层演算lambda x . plus x y中，y和plus是自由的，x是绑定的。在完整表达中，x和y是绑定的：x受内层绑定，而y由剩下的演算绑定。plus仍然是自由的。
我们会经常使用free(x)来表示在表达式x中自由的标识符。
一个Lambda演算表达式只有在其所有变量都是绑定的时候才完全合法。但是，当我们脱开上下文，关注于一个复杂表达式的子表达式时，自由变量是允许存在的——这时候搞清楚子表达式中的哪些变量是自由的就显得非常重要了。

### LC两条真正的法则
   - Alpha 称「转换」
   - Beta也被称为「规约」
   - Alpha equivalence( or conversion )
   - Beta reduction

Alpha是一个重命名操作; 基本上就是说，变量的名称是不重要的：给定Lambda演算中的任意表达式，我们可以修改函数参数的名称，只要我们同时修改函数体内所有对它的自由引用。
所以 —— 例如，如果有这样一个表达式：

> lambda x . if (= x 0) then 1 else x ^ 2 

我们可以用Alpha转换，将x变成y（写作alpha[x / y]），于是我们有：

lambda y . if (= y 0) then 1 else y ^ 2 

这样丝毫不会改变表达式的含义。但是，正如我们将在后面看到的，这一点很重要，因为它使得我们可以实现比如递归之类的事情。

Beta基本上是说，如果你有一个函数应用，你可以对这个函数体中和对应函数标识符相关的部分做替换，替换方法是把标识符用参数值替换。这听起来很费解，但是它用起来却很容易。

假设我们有一个函数应用表达式：“ (lambda x . x + 1) 3 “。所谓Beta规约就是，我们可以通过替换函数体（即“x + 1”）来实现函数应用，用数值“3”取代引用的参数“x”。于是Beta规约的结果就是“3 + 1”。

一个稍微复杂的例子：(lambda y . (lambda x . x + y)) q。 这是一个挺有意思的表达式，因为应用这个Lambda表达式的结果是另一个Lambda表达式：也就是说，它是一个创建函数的函数。这时候的Beta规约，需要用标识符“q”替换所有的引用参数“y”。所以，其结果是“ lambda x . x + q “。

再给一个让你更不爽的例子：“ (lambda x y. x y) (lambda z . z * z) 3 “。这是一个有两个参数的函数，它(的功能是)把第一个参数应用到第二个参数上。当我们运算时，我们替换第一个函数体中的参数“x”为“lambda z . z * z “；然后我们用“3”替换参数“y”，得到：“ (lambda z . z * z) 3 “。 再执行Beta规约，有“3 * 3”。

Beta规则的形式化写法为：

lambda x . B e = B[x := e] if free(e) subset free(B[x := e])
最后的条件“if free(e) subset free(B[x := e])”说明了为什么我们需要Alpha转换：我们只有在不引起绑定标识符和自由标识符之间的任何冲突的情况下，才可以做Beta规约：如果标识符“z”在“e”中是自由的，那么我们就需要确保，Beta规约不会导致“z”变成绑定的。如果在“B”中绑定的变量和“e”中的自由变量产生命名冲突，我们就需要用Alpha转换来更改标识符名称，使之不同。

例子更能明确这一点：假设我们有一个函数表达式，“ lambda z . (lambda x . x + z) “，现在，假设我们要应用它：
 
 > (lambda z . (lambda x . x + z)) (x + 2)

参数“(x + 2)”中，x是自由的。现在，假设我们不遵守规则直接做Beta规约。我们会得到：

 > lambda x . x + x + 2

原先在“x + 2”中自由的的变量现在被绑定了。再假设我们应用该函数：

> (lambda x . x + x + 2) 3

通过Beta规约，我们会得到“3 + 3 + 2”。

如果我们按照应有的方式先采用Alpha转换，又该如何？

由 alpha[x/y] 有: (lambda z . (lambda y . y + z)) (x + 2)

由Beta规约： (lambda y . y + x + 2) 3

再由Beta规约： 3 + x + 2 。

“3 + x + 2”和“3 + 3 + 2”是非常不同的结果！

规则差不多就是这些。还有另外一个规则，你可以选择性地加一条被称为Eta-规约的规则，不过我们将跳过它。 我在这里描述了一个图灵完备 —— 完整有效的计算系统。 要让它变得有用，或看它如何用来做些有实际意义的事情，我们还需要定义一堆能让我们做数学计算的基本函数，条件测试，递归等，我将在下一篇文章讨论这些。

我们也还没有定义Lambda-演算的模型呢。（原作者在这里和这里讨论了模型的概念。）模型实际上是非常重要的！逻辑学家们在摆弄了LC好几年之后，才为其想出一个完整的模型，这是件非常重要的事情，因为虽然LC看起来是正确的，但在早期为它定义一个模型的尝试，却是失败的。毕竟，请记住，如果没有一个有效的模型，这意味着该系统的结果是毫无意义的！

